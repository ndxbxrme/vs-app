// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  angular.module('vs-agency').controller('agencyAgreedCtrl', function($scope, $filter, $timeout, $http) {
    var updateMonths, updateProperties, updateTargets, y;
    $scope.filterMode = "1";
    $scope.now = new Date().valueOf();
    $scope.firstLoad = false;
    $scope.years = [];
    y = new Date().getFullYear() + 1;
    while (y-- > 2017) {
      $scope.years.push(y);
    }
    updateMonths = function() {
      var month, results, testDate;
      $scope.months = [];
      testDate = new Date($scope.startDate['startDate']);
      results = [];
      while (testDate < $scope.endDate['startDate']) {
        month = {
          date: testDate,
          month: $filter('date')(testDate, 'MMMM'),
          properties: [],
          target: {
            type: 'salesAgreed',
            value: 0,
            date: testDate
          },
          search: ''
        };
        $scope.months.push(month);
        results.push(testDate = new Date(testDate.getFullYear(), testDate.getMonth() + 1, testDate.getDate()));
      }
      return results;
    };
    $scope.startDate = {
      startDate: 0
    };
    $scope.endDate = {
      startDate: 0
    };
    $scope.setDateRange = function(year) {
      return $timeout(function() {
        $scope.startDate.startDate = new Date(year, 0, 1).valueOf();
        $scope.endDate.startDate = new Date(year + 1, 0, 1).valueOf();
        updateMonths();
        updateTargets();
        return updateProperties();
      });
    };
    $scope.currentYear = $scope.years[0];
    $scope.setDateRange($scope.currentYear);
    $scope.$watch('currentYear', function(newYear, oldYear) {
      if (newYear && newYear !== oldYear) {
        $scope.setDateRange(newYear);
      }
    });
    updateTargets = function() {
      var j, len, month, ref, results, target;
      if ($scope.targets && $scope.targets.items && $scope.targets.items.length) {
        ref = $scope.targets.items;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          target = ref[j];
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = $scope.months;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              month = ref1[k];
              if (new Date(target.date).toLocaleString() === month.date.toLocaleString()) {
                month.target = target;
                break;
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          })());
        }
        return results;
      }
    };
    let historic = {};
    ['2017', '2018', '2019', '2020', '2021', '2022'].map(year => $http.get('/public/data/conveyancing-agreed-' + year + '.json').then(res => {
      if (res.data && Array.isArray(res.data)) {
        historic[year] = res.data.map(m => m.map(p => ({
          roleId: p.roleId,
          address: p.address,
          commission: p.commission,
          delisted: p.delisted,
          date: p.date
        })));
      }
    }).catch(err => {
      console.log('Failed to load historic data for year:', year);
    }));
    function rebuildMonthsFiltered() {
      const filtered = $filter('filter')($scope.months, $scope.search);
      $scope.monthsFiltered = $filter('orderBy')(filtered, 'date');
    }
    updateProperties = function () {
      // Reset months quickly
      const months = $scope.months || [];
      for (let m = 0; m < months.length; m++) {
        months[m].properties = [];
        months[m].commission = 0;
      }
      
      rebuildMonthsFiltered();

      if (!($scope.properties && $scope.properties.items)) return;

      const yearKey = String($scope.currentYear);
      const filterMode = $scope.filterMode;
      const items = $scope.properties.items;
      const endStart = new Date($scope.endDate.startDate);

      // Fast path: historic
      if (typeof historic !== "undefined" && historic && historic[yearKey]) {
        for (let f = 0; f < months.length; f++) {
          // Filter once; sum once
          const list = historic[yearKey][f] || [];
          const filtered = (filterMode === "2")
            ? list.filter(p => p.pipeline === "HOME")
            : list;
          months[f].properties = filtered;
          let c = 0;
          for (let p = 0; p < filtered.length; p++) c += +filtered[p].commission || 0;
          months[f].commission = c;
        }
        $timeout(() => {
          rebuildMonthsFiltered();
          $scope.firstLoad = true;
          $scope.$applyAsync();
        });
        return;
      }

      // Precompute month start dates (assumed ascending) for binary search
      const monthStarts = months.map(m => m.date);

      function monthIndexFor(date) {
        // find the last month whose start < date
        let lo = 0, hi = monthStarts.length - 1, ans = -1;
        while (lo <= hi) {
          const mid = (lo + hi) >> 1;
          if (monthStarts[mid] < date) { ans = mid; lo = mid + 1; }
          else { hi = mid - 1; }
        }
        return ans;
      }

      for (let p = 0; p < items.length; p++) {
        const property = items[p];

        // filterMode short-circuits
        if (filterMode === "1" && property.pipeline === "HOME") continue;
        if (filterMode === "2" && property.pipeline !== "HOME") continue;

        const start = new Date(property.startDate);
        // quick reject (keeps logic equivalent to your checks)
        if (!(endStart > start && start > monthStarts[0])) continue;

        const idx = monthIndexFor(start);
        if (idx < 0) continue; // falls before first month

        // compute completeBeforeDelisted safely
        let completeBeforeDelisted = false;
        if (property.progressions && property.progressions.length) {
          const progression = property.progressions[0];
          const milestones = progression.milestones || [];
          if (milestones.length) {
            const last = milestones[milestones.length - 1];
            // preserve your original truthiness logic
            completeBeforeDelisted =
              (!last[0].completed && property.delisted) || !property.delisted;
          }
        }

        const ov = property.override || {};
        if (ov.deleted) continue;

        const commission = (+ov.commission) || (property.role && +property.role.Commission) || 0;

        const month = months[idx];
        month.commission += commission;

        // build once, avoid repeated deep access with locals
        const offerAddr = property.offer && property.offer.Property && property.offer.Property.Address;
        const defaultAddress = offerAddr
          ? `${offerAddr.Number} ${offerAddr.Street}, ${offerAddr.Locality}`
          : ""; // fallback defensively

        month.properties.push({
          _id: property._id,
          address: ov.address || defaultAddress,
          commission: ov.commission || (property.role && property.role.Commission) || 0,
          date: ov.date || property.startDate,
          roleId: property.roleId,
          delisted: property.delisted,
          completeBeforeDelisted
        });
      }
      $timeout(() => {
        rebuildMonthsFiltered();
        $scope.firstLoad = true;
        $scope.$applyAsync();
      })
    };
    $scope.getYearTotal = () => {
      if(!$scope.months) return 0;
      let total = $scope.months.reduce((res, val) => {return res + val.commission}, 0);
      return total;
    };
    
    $scope.getTotalSold = function() {
      if (!$scope.months) return 0;
      return $scope.months.reduce((total, month) => total + (month.properties ? month.properties.length : 0), 0);
    };
    
    $scope.getTotalFees = function() {
      return $scope.getYearTotal();
    };
    
    $scope.getSalesRequiredToTarget = function() {
      if (!$scope.months) return 0;
      const totalTarget = $scope.months.reduce((total, month) => total + (month.target ? parseFloat(month.target.value) || 0 : 0), 0);
      const totalSold = $scope.getTotalSold();
      const remaining = totalTarget - totalSold;
      return remaining > 0 ? remaining : 0;
    };
    $scope.$watchGroup(['months', 'search'], function () {
      if (!$scope.months) { $scope.monthsFiltered = []; return; }
      rebuildMonthsFiltered();
    });
    $scope.updateProperties = updateProperties;
    $scope.targets = $scope.list('agency:targets', {
      where: {
        type: 'salesAgreed'
      }
    }, updateTargets);
    $scope.properties = $scope.list('agency:properties', {
      where: {
        startDate: {
          $gt: new Date('2022-12-20').valueOf()
        }
      },
      sort: 'startDate',
      sortDir: 'ASC'
    }, updateProperties);
    $scope.open = function(selectedMonth) {
      if (!selectedMonth.open) {
        // Open modal
        const modalTemplate = `
          <div class="modal properties-modal">
            <div class="modal-header">
              <h2>{{month.month}} {{year}}</h2>
              <div class="snapshot">
                <div class="snapshot-item">
                  <div class="snapshot-label">Total Properties</div>
                  <div class="snapshot-value">{{month.properties.length}}</div>
                </div>
                <div class="snapshot-item">
                  <div class="snapshot-label">Commission</div>
                  <div class="snapshot-value" ng-bind-html="(month.commission | currency:'£' | currencyFormat)"></div>
                </div>
              </div>
            </div>
            <div class="properties-list">
              <div class="property-card" ng-repeat="property in month.properties track by property._id" ng-class="{delisted:property.delisted, editing: property.$editing}" data-tooltip="{{::property.date | date:'mediumDate'}}">
                <div class="editor" ng-if="property.$editing">
                  <div class="row g-3">
                    <div class="col-8">
                      <label>Address</label>
                      <input type="text" ng-model="property.$override.address"/>
                    </div>
                    <div class="col-4">
                      <label>Commission</label>
                      <input type="text" ng-model="property.$override.commission"/>
                    </div>
                  </div>
                  <div class="button-group">
                    <input class="small button save" type="button" ng-click="save(property)" value="Save"/>
                    <input class="small button cancel" type="button" ng-click="cancelEdit(property)" value="Cancel"/>
                  </div>
                </div>
                <div class="default" ng-if="!property.$editing">
                  <div class="property-header">
                    <div class="property-number">{{$index + 1}}</div>
                    <div class="property-address">{{::property.address}} <span class="property-commission" ng-bind-html="::(property.commission | currency:'£' | currencyFormat)"></span></div>
                    <div class="property-controls" ng-show="auth.checkRoles(['admin','superadmin'])">
                      <a href="" ng-click="edit(property)"><i class="fa-light fa-pen-to-square"></i></a>
                      <a href="" ng-click="deleteProperty(property)"><i class="fa-light fa-trash-can"></i></a>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <a class="close-reveal-modal" ng-click="cancel()">&times;</a>
          </div>
        `;
        
        selectedMonth.open = true;
        $scope.modal({
          template: modalTemplate,
          controller: 'agencyAgreedPropertiesCtrl',
          data: {
            month: selectedMonth,
            year: $scope.currentYear,
            save: $scope.save,
            edit: $scope.edit,
            deleteProperty: $scope.delete,
            cancelEdit: $scope.cancel
          }
        }).then(() => {
          selectedMonth.open = false;
        }, () => {
          selectedMonth.open = false;
        });
      }
    };
    $scope.edit = function(property) {
      if (!property.$override) {
        property.$override = {
          address: property.address,
          commission: property.commission,
          date: property.date
        };
      }
      return $timeout(function() {
        return property.$editing = true;
      });
    };
    $scope.delete = function(property) {
      return $http.post($http.sites["agency"].url + `/api/properties/${property._id}`, {
        override: {
          deleted: true
        }
      }, $http.sites.agency.config);
    };
    $scope.save = function(property) {
      return $http.post($http.sites["agency"].url + `/api/properties/${property._id}`, {
        override: property.$override
      }, $http.sites.agency.config);
    };
    $scope.cancel = function(property) {
      return property.$editing = false;
    };
    return $scope.saveTarget = function(month) {
      $http.post($http.sites["agency"].url + `/api/targets/${month.target._id || ''}`, month.target, $http.sites.agency.config);
      return month.editing = false;
    };
  });
  
  // Modal controller for properties list
  angular.module('vs-agency').controller('agencyAgreedPropertiesCtrl', function($scope, data, ndxModalInstance) {
    $scope.month = data.month;
    $scope.year = data.year;
    $scope.edit = data.edit;
    $scope.save = data.save;
    $scope.deleteProperty = data.deleteProperty;
    $scope.cancelEdit = data.cancelEdit;
    
    $scope.cancel = function() {
      return ndxModalInstance.dismiss();
    };
  });

}).call(this);
